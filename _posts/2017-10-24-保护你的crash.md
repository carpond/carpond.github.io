---
title: 保护你的crash
date: 2017-10-24 08:00:00
categories:
- APM
tags:
- performance
- APM
---

如何去衡量一款应用的质量好坏？为了回答这一问题，目的性极强的`APM`开发顺应而生。最初的`APM`只关心`crash`、`cpu`这类的硬性指标。但随着移动开发市场的成熟，`APM`也加入了其他与感官体验相关的质量监控，以及使用习惯采集等。

然而，无论`APM`最终如何发展，`crash`采集也一定会是最核心的功能。完善的`crash`监控方案可以快速的发现并帮助开发定位问题，及时的完成止损，避免因此造成用户流失。而反过来说，如果不能及时的发挥作用，又或者因为处理不当导致了数据丢失，对于开发者和公司来说，这都是一个噩梦。

## 采集方式
细分之后，`crash`可以被分为`mach exception`、`signal`以及`NSException`三种类型，每一种类型有着对应的捕获方式：

- `mach exception`
 
    `mach exception`通过端口的方式传递，在异常抛出之后会依次投递到`thread`、`task`和`host`端口。系统提供了一部分的端口`API`，包括创建和注册对应的`exception handler`。但即便我们注册了对应的处理程序，也不会干扰原有的投递流程，最终`mach exception`会经过一系列的转换成为`signal`信号。
    ![](http://upload-images.jianshu.io/upload_images/2833754-009bdca3149d428a.png?imageMogr2/auto-orient/strip%7CimageView2/2)

- `NSException`
 
    `NSException`对异常信息进行了抽象封装，面向对象的设计使得我们可以使用`try-catch`来避免应用异常崩溃，这是其他两种`crash`不具备的。和`mach exception`一样，`NSException`同样能被转换成`SIGABRT`抛出。另外，假如我们使用`NSSetUncaughtExceptionHandler`去注册回调处理，那么对应的`crash`不会转换成`signal`

- `signal`
 
    `signal`是一种强大的机制，异常处理仅仅是它一部分的功能。`signal.h`文件中声明了`32`种异常信号，一般`crash`需要捕获的为`6-8`种。对于每一种`signal`异常，都能在网上找到具体的异常信息，这里不再多说。由于`mach exception`和`NSException`最终都能被转换成`signal`，因此理论上我们只需要注册`signal`的处理就可以了
    
    ![](http://upload-images.jianshu.io/upload_images/783864-e62ce7845472cb94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    
    由于`crash`的捕获机制只允许我们注册一个回调函数，因此多个`crash采集框架`很可能会存在冲突。为了避免冲突导致回调流程失效，注册前都应该检测是否存在已注册的`handler`，保证多个`handler`可以像响应链一般连续的执行下去。以信号注册`sigaction`函数为例，正确的注册代码如下：
        
        static struct sigaction registered_action;
        struct sigaction my_action;
            
        void signal_handler(int signal) {
            ......
        }
            
        myAction.sa_handler = &signal_handler;
        sigemptyset(&my_action.sa_mask);
        sigaction(SIGABRT, &my_action, &registered_action);
    
但是，即便我们对冲突做了防范处理，并不代表第三方框架在我们注册之后会同样善待我们的`handler`。某年某月，线上的`crash`上报数量堪称飞流直下三千尺。经过了一系列的排查，最终发现问题出在第三方注册了多个与我们相同的`signal`回调并且没有做冲突处理。

## 冲突解决方案
解决问题应当寻求代价最小的方案，并且要避免相同的问题今后发生之后也能有效的解决。另外，除了要保护我们自己的`crash`回调之外，由于回调的过程中存在`二次crash`以及`人工abort`的风险，我们应当保证我们的`handler`是第一个被回调的。首先除开`load`阶段发生`crash`的可能，为了减少遗漏，注册的时机应当是尽可能的提前。所以大部分框架选择注册`crash`的时机是在`didLaunch`方法里面。

![](http://upload-images.jianshu.io/upload_images/783864-ddd56666f11ae7de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 周期性检测
利用已有或者新建一个周期回调，去检测我们注册的`handler`是否被替换，然后做对应的处理。

- 监听应用状态

    基本上在应用进入`active`状态之前，`crash`相关的注册都已经完成，我们可以接收对应的状态通知来保护我们注册的`handler`
    
        - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
            ......
            [[NSNotificationCenter defaultCenter] addObserver: [SignalHandler sharedHandler] selector: @selector(checkRegisterCrashHandler) name: UIApplicationDidBecomeActiveNotification object: nil];
            ......   
        }
        
        static struct sigaction existActions[32];
        static int fatal_signals[] = {
            SIGILL,
            SIGBUS,
            SIGABRT,
            SIGPIPE,
        };
        
        - (void)checkRegisterCrashHandler {
            struct sigaction oldAction;
            for (int idx = 0; idx < sizeof(fatal_signals) / sizeof(int); idx++) {
                sigaction(fatal_signals[idx], NULL, &oldAction);
                if (oldAction.sa_handler != &signal_handler) {
                    existActions[fatal_signals[idx]] = oldAction;
                    
                    struct sigaction myAction;
                    myAction.sa_handler = &signal_handler;
                    sigemptyset(&myAction.sa_mask);
                    sigaction(SIGABRT, &myAction, NULL);
                }
            }
        }
    
- 定时器检测

    创建定时器来控制检测周期，比起监听应用状态有更强的可控性。

        - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
            ......
            NSTimer *timer = [[NSTimer alloc] initWithFireDate: [NSDate date] interval: 30 target: [SignalHandler sharedHandler] selector: @selector(checkRegisterCrashHandler) userInfo: nil repeats: YES];
            [[NSRunLoop currentRunLoop] addTimer: timer forMode: NSRunLoopCommonModes];
            [timer fire];
            ......   
        }
        
周期性检测方案存在的风险是，如果在两个周期之间发生了注册冲突，并且随后发生`crash`时，并不能保证我们的`handler`会被调起。周期性检测的方案优点在于简单，但是由于重复注册`handler`，可能导致回调时也被多次调用。

#### hook
虽然`crash`相关的捕获接口都是`C`语言编写的，但[fishhook](https://github.com/facebook/fishhook)提供了对于`C`语言级别的`hook`方案。通过`hook`对应的捕获接口，检测注册的`handler`是否为我们的回调：

    struct SignalHandler {
        void (*signal_handler)(int);
        struct SignalHandler *next;
    }
    struct SignalHandler *previousHandlers[32];

    void append(struct SignalHandler *handlers, struct SignalHandler *node) { 
        ......
    }
    
    static int (*origin_sigaction)(int, const struct sigaction *__restrict, struct sigaction * __restrict) = NULL;
    
    int custom_sigaction(int signal, const struct sigaction *__restrict new_action, struct sigaction * __restrict old_action) {
        if (new_action.sa_handler != signal_handler) {
            append(previousHandlers[signal], new_action);
            return origin_sigaction(signal, NULL, old_action);
        } else {
            return origin_sigaction(signal, new_action, old_action);
        }
    }
    
如果检测到即将注册的`handler`不是我们的注册函数，那么将注册的回调添加到回调链表中，在我们处理完成之后逐一唤起调用。这种`hook`机制存在的一个风险是假如我们先进行了注册，后续其他的注册如果做了冲突处理。那么由于其他`handler`会保留已注册的回调函数，就是我们的`signal_handler`，将会导致`crash`发生后，我们的`signa_handler`将会被调起多次：

![](http://upload-images.jianshu.io/upload_images/783864-ee8d855066b6351a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](http://upload-images.jianshu.io/upload_images/783864-3dff6046e47956e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

解决方案之一是永远不告诉其他的注册者已经存在的回调函数，避免发生二次回调：

    int custom_sigaction(int signal, const struct sigaction *__restrict new_action, struct sigaction * __restrict old_action) {
        if (new_action.sa_handler != signal_handler) {
            append(previousHandlers[signal], new_action);
            return origin_sigaction(signal, NULL, NULL);
        } else {
            return origin_sigaction(signal, new_action, old_action);
        }
    }
    
又或者在我们的`signal_handler`中采用单例方式写法，保证回调处理只被执行一次：

    void signal_handler(int signal) {
        static dispatch_once_t onceToken;
        dispatch_once(&onceToken, ^{
            ......
        });
    }
    
`hook`的方式对注册的回调函数有了更高的控制力，并且保证回调的顺序总是我们的回调在前。但是，如果其他框架中同样`hook`了相同的函数，做了过滤处理，可能将导致所有的`handler`都被过滤掉，最终所有的`crash`捕获都失效。

## 最简单的方式
![](http://upload-images.jianshu.io/upload_images/783864-c1d0dc3ace633edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上述的方法都或多或少存在自己的不足，那么有没有不需要改动那么大，又可以避免发生采集冲突的做法呢？答案是不用冲突的`SDK`或者和对方协商提供一个不冲突的版本。

![](http://upload-images.jianshu.io/upload_images/783864-c9fff26dd02e604a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 尾言
踩坑是件很有趣的事情。踩坑让我们支付了时间、精力、甚至`KPI`，但是踩过的坑越多，我们才会越强大。

## 参考
[iOS异常捕获](http://www.iosxxx.com/blog/2015-08-29-iosyi-chang-bu-huo.html)

[Linux信号处理机制](http://hutaow.com/blog/2013/10/19/linux-signal/)

[浅谈Mach Exceptions](http://www.jianshu.com/p/725e7d69272c)

[漫谈iOS Crash收集框架](https://nianxi.net/ios/ios-crash-reporter.html)

[源码剖析signal和sigaction的区别](http://blog.csdn.net/wangzuxi/article/details/44814825)

[iOS Crash捕获及堆栈符号化思路剖析](http://www.jianshu.com/p/29051908c74b)


