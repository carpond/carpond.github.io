---
title: 隐式动画的性能瓶颈
date: 2017-11-01 08:00:00
categories:
- Note
- performance
tags:
- performance
- APM
---

`隐式动画`实现的背后体现了核心动画精心设计的许多机制。在`layer`的属性发生改变之后，会向它的代理方请求一个`CAAction`行为来完成后续的工作，系统允许代理方返回`nil`指针。一旦这么做，修改属性的工作最终移交给`CATransaction`处理，如果此时被修改的属性是可以展示动画的，那么此时就满足了隐式动画的实现条件。

### 了解隐式动画的必要

首先，`隐式动画`是相对于`显式动画`而言的，属于被动实现。由于`显式动画`是主动实现的，因此在实现这些动画的时候，我们会去考虑动画是否流畅，动画前后是否会有卡帧，也会不断的运行来保证动画效果如预期完成。而`隐式动画`多属于系统自己完成的动画效果，提供给我们的可调试空间也很小，这也导致了开发者对它的重视不够，从而阻碍了进一步学习技术的可能。

其次，和用户直接进行交互的就是`UI`元素。在发生卡帧、掉帧的性能问题时，用户对静止界面和动画的感知是完全不同的。即便只有`1`帧页面丢失，在动画中也能轻易的被用户捕捉。举个例子，当用户按下按钮，应用推迟了`1、2`帧才开始跳转。又或者是在界面跳转时丢失帧数据，具体表现为卡帧，此时用户对于卡顿的感知是远远大于平常的，因此定位`隐式动画`过程中如何发生卡顿是很有必要的。

### 隐式动画何时开始
在核心动画中，`layer`属性的修改并不会直接导致动画，而是被包装成一个`transaction`事务对象进行处理，这个对象分为`implicit`和`explicit`两种类型，分别对应`隐式`和`显式`。`implicit transaction`会被投递到线程的下一个`runloop`完成处理：

> Core Animation supports two types of transactions: implicit transactions and explicit transactions. Implicit transactions are created automatically when the layer tree is modified by a thread without an active transaction and are committed automatically when the thread's runloop next iterates.

核心动画在主线程的`runloop`注册了一个监听者，具体回调发生在`before waiting`阶段，在回调中会将所有`implicit transactions`以动画的形式实现。虽然苹果文档没有明说这一机制，但通过简单的代码可以测试这个机制。注册两个`runloop`监听者，回调优先级分别设为`NSIntegerMax`和`NSIntegerMin`，保证其他回调处在这两个监听者中间：

    - (void)viewDidLoad {
        [super viewDidLoad];
        
        CFRunLoopObserverContext ctx = { 0, (__bridge void *)self, NULL, NULL };
        CFRunLoopObserverRef allActivitiesObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, YES, NSIntegerMin, &__runloop_callback, &ctx);
        CFRunLoopAddObserver(CFRunLoopGetCurrent(), allActivitiesObserver, kCFRunLoopCommonModes);
        
        CFRunLoopObserverRef beforeWaitingObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, YES, NSIntegerMax, &__runloop_before_waiting_callback, &ctx);
        CFRunLoopAddObserver(CFRunLoopGetCurrent(), beforeWaitingObserver, kCFRunLoopCommonModes);
    }
    
#### layer的隐式动画
直接修改`CALayer`的属性可以产生隐式动画，`UIView`会自动成为其绑定的`layer`的代理对象，在相关的代理回调中阻止了隐式动画的产生。如果想要实现`layer`修改属性后的隐式动画，我们需要自己新建一个单独的`CALayer`对象。然后在按钮点击发生的时候，修改它的`transform`属性实现隐式动画：

    self.circle = [CAShapeLayer layer];
    self.circle.delegate = self;
    self.circle.anchorPoint = CGPointMake(0.5, 0.5);
    self.circle.fillColor = [UIColor orangeColor].CGColor;
    self.circle.path = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(CGRectGetMidX([UIScreen mainScreen].bounds) - 50, 80, 100, 100)].CGPath;
    [self.view.layer addSublayer: self.circle];

通过断点和界面显示可以看到在`Before Waiting`阶段的两次回调之间，`transaction`已经完成了属性修改的渲染任务：

![](http://upload-images.jianshu.io/upload_images/783864-4e5074dd2f4b3252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](http://upload-images.jianshu.io/upload_images/783864-1f6f85b899a145f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 页面跳转
大多数的开发者并不了解`页面跳转`也和隐式动画有关，`present`和`push`的跳转方式会以隐式动画执行并且开始。通过`hook`掉`UIView`的`CALayerDelegate`相关方法输出实际的`CAAction`，确实涉及到了一个私有的转场动画子类`_UIViewAdditiveAnimationAction`用来完成跳转的动画。


