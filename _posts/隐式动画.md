---
title: 隐式动画
date: 2017-11-01 08:00:00
categories:
- Note
- performance
tags:
- performance
- APM
---

`隐式动画`实现的背后体现了核心动画精心设计的许多机制。在`layer`的属性发生改变之后，会向它的代理方请求一个`CAAction`行为来完成后续的工作，系统允许代理方返回`nil`指针。一旦这么做，修改属性的工作最终移交给`CATransaction`处理，如果此时被修改的属性是可以展示动画的，那么此时就满足了隐式动画的实现条件。

### 了解隐式动画的必要

首先，`隐式动画`是相对于`显式动画`而言的，属于被动实现。由于`显式动画`是主动实现的，因此在实现这些动画的时候，我们会去考虑动画是否流畅，动画前后是否会有卡帧，也会不断的运行来保证动画效果如预期完成。而`隐式动画`多属于系统自己完成的动画效果，提供给我们的可调试空间也很小，这也导致了开发者对它的重视不够，从而阻碍了进一步学习技术的可能。

其次，和用户直接进行交互的就是`UI`元素。在发生卡帧、掉帧的性能问题时，用户对静止界面和动画的感知是完全不同的。即便只有`1`帧页面丢失，在动画中也能轻易的被用户捕捉。举个例子，当用户按下按钮，应用推迟了`1、2`帧才开始跳转。又或者是在界面跳转时丢失帧数据，具体表现为跳帧，此时用户对于卡顿的感知是远远大于平常的。

### 隐式动画何时开始
在核心动画中，`layer`属性的修改并不会直接导致动画，而是被包装成一个`transaction`事务对象进行处理，这个对象分为`implicit`和`explicit`两种类型，分别对应`隐式`和`显式`。`implicit transaction`会被投递到线程的下一个`runloop`完成处理：

> Core Animation supports two types of transactions: implicit transactions and explicit transactions. Implicit transactions are created automatically when the layer tree is modified by a thread without an active transaction and are committed automatically when the thread's runloop next iterates.

核心动画在主线程的`runloop`注册了一个监听者，具体回调发生在`before waiting`阶段，在回调中会将所有`implicit transactions`以动画的形式实现。虽然苹果文档没有明说这一机制，但通过简单的代码可以测试这个机制。注册两个`runloop`监听者，回调优先级分别设为`NSIntegerMax`和`NSIntegerMin`，保证其他回调处在这两个监听者中间：

    - (void)viewDidLoad {
        [super viewDidLoad];
        
        CFRunLoopObserverContext ctx = { 0, (__bridge void *)self, NULL, NULL };
        CFRunLoopObserverRef allActivitiesObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, YES, NSIntegerMin, &__runloop_callback, &ctx);
        CFRunLoopAddObserver(CFRunLoopGetCurrent(), allActivitiesObserver, kCFRunLoopCommonModes);
        
        CFRunLoopObserverRef beforeWaitingObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, YES, NSIntegerMax, &__runloop_before_waiting_callback, &ctx);
        CFRunLoopAddObserver(CFRunLoopGetCurrent(), beforeWaitingObserver, kCFRunLoopCommonModes);
    }


