---
title: 倒计时设计
date: 2018-01-06 08:00:00
categories:
- Note
tags:
- Note
- Tips
---

计算机是不存在倒计时这个概念的，所有的倒计时设计来源于对定时器的运用：给予一个`deadline`，以秒为时间间隔，在每次回调时刷新屏幕上的数字。倒计时的实现几乎没有门槛，无论`NSTimer`也好，`GCD`也罢，甚至使用`CADisplayLink`都能用来制作一个倒计时方案。但同样的，低门槛也意味着方案的上下限差也很大，本文打算谈谈如何设计一个倒计时方案

### 为什么要写这篇文章
事实上，倒计时和我目前开发的方向八竿子打不着，我也确实没有必要和想法写这么一套东西。只是这几天有朋友分享了别人设计的倒计时功能：

> 采用一个全局计时管理对象针对每一个倒计时按钮分配计时器，计时器会生成一个`NSOperation`对象来执行回调，完成倒计时功能

在抛开代码不谈的情况下，这套设计思路我也是存疑的。如果倒计时要使用`operation`，那就需要使用`queue`来完成任务。根据`queue`的串行并行属性，要考虑这两点：

- 如果`queue`是并行的，一个界面上存在多个倒计时按钮时，可能会新建线程来处理同一个`queue`的任务，这部分的开销并不是必需的

- `operation`需要投放到`queue`里面启动执行。假如每秒的回调包装成`operation`处理，那么需要一个定时机制来投放这些`operation`。如果是这么，为什么不直接使用定时器，而要用`operation`

但在看完设计者的文章和代码之后，我发现对方根本没有考虑过上面的问题。他`operation`的任务思路很奇怪：

> 在每一个`operation`里面，采用`while + sleep`的方式，每次回调后让线程睡眠一秒，直至倒计时结束

    - (void)main {
        ......
        do {
            callback(self.leftTime);
            [NSThread sleepForTimeInterval: 1];
        } while (--self.leftTime > 0);
        ......
    }

这种实现有三个坑爹的地方：

1. `while`循环结束之前，内部的临时变量不会被释放，存在内存占用过大的风险

2. 如果`queue`是串行属性，多个`operation`将无法保证回调时间的正确

3. 不应该采用`sleep`方式计时，这很浪费线程的执行效率

另外，应用进入后台时，所有的子线程会被停止执行任务，这个会导致了应用切换前后台后，倒计时剩余时间不准。对于这种情况一般也有三种方式来做时间校正：

1. 保存一个倒计时`deadline`，在进入`active`后重新计算剩余倒计时

2. 注册通知，在切换前后台时计算时长，减去这个时间更新剩余时间

3. 创建应用后台任务，继续进行倒计时

而上面的设计采用了`3`的解决方案，鉴于应用在后台时，用户对应用毫无感知的特点，这几乎是最差的一种方案。于是基于这一个个槽点，我决定按照自己的想法，做一个相对高效的倒计时方案

### 定时器选择
`iOS`里常用的定时器包括`NSTimer`和`GCD`，处于两点考虑，我选择了后者：

1. `NSTimer`需要启动子线程的`runloop`

2. `GCD`更加精准，效率也更高

开工前还有另一个考虑：使用`多定时器`还是`单定时器`设计？

- `多定时器`

    多定时器的设计下，每个倒计时任务拥有自己的计时系统。缺点是由于倒计时系统是独立的个体，在更新页面时会出现不同步的现象
    
- `单定时器`

    单定时器的设计下，所有倒计时任务使用同一个计时系统。缺点是，由于倒计时回调的时间统一了，那么在倒计时任务开始后的第一次回调，很有可能不到一秒
    
为了回调的刷新同步、以及更好的性能，我选择了`单定时器`设计

![](http://p0zs066q3.bkt.clouddn.com/2018010601.png)

### 设计思路
为了性能以及避免循环引用，设计结构体保存回调`block`、倒计时长和对象地址，对象地址作`id`标识作用：

    /*!
     *  @structure  LXDReceiver
     *  存储回调结构体
     *
     *  @var    lefttime        倒计时时长
     *  @var    objaddr         保留的对象地址
     *  @var    callback        回调block
     */
    typedef struct LXDReceiver {
        long lefttime;
        uintptr_t objaddr;
        LXDReceiverCallback callback;
    } LXDReceiver;

同样将定时器管理设计成单例使用，由于回调对象可能在倒计时完成之前就结束倒计时任务，借鉴`enum`的停止机制，回调传入一个`BOOL *`变量，允许设置为`YES`，提前结束任务

    /*!
     *  @block  LXDTimerCallback
     *  回调block
     *
     *  @params leftTime    倒计时剩余秒数
     *  @params isStop      等同于enum的isStop，修改为YES后定时任务结束
     */
    typedef void(^LXDTimerCallback)(long leftTime, bool *isStop);

    /*!
     *  @class  LXDTimerManager
     *  定时器管理
     */
    @interface LXDTimerManager : NSObject
    
    /*!
     *  @method timerManager
     *  获取定时器管理对象
     */
    + (instancetype)timerManager;
    
    /*!
     *  @method registerCountDown:forSeconds:withReceiver:
     *  注册倒计时回调
     *
     *  @params countDown   回调block
     *  @params seconds     倒计时长
     *  @params receiver    注册的对象
     */
    - (void)registerCountDown: (LXDTimerCallback)countDown
                   forSeconds: (NSUInteger)seconds
                 withReceiver: (id)receiver;
    
    @end

在倒计时回调中，遍历所有的`receivers`，一旦任务的倒计时结束或者标记位被修改，那么从存储结构中剔除注册者：

    - (void)_countDown {
        unsigned int receiversCount = 0;
        for (unsigned int offset = 0; offset < _receives->entries_count; offset++) {
            hash_entry_t *entry = _receives->hash_entries + offset;
            LXDReceiverNode *header = (LXDReceiverNode *)entry->entry;
            __block LXDReceiverNode *node = header->next;
            
            dispatch_async(dispatch_get_main_queue(), ^{
                lxd_wait(self.lock);
                while (node != NULL) {
                    LXDReceiver *receiver = node->receiver;
                    LXDReceiverNode *next = node->next;
                    receiver->lefttime--;
                    
                    bool isStop = false;
                    receiver->callback(receiver->lefttime, &isStop);
                    if (receiver->lefttime <= 0 || isStop) {
                        _receives->destoryNode(node);
                        header->count--;
                    }
                    node = next;
                }
                lxd_signal(self.lock);
            });
            receiversCount += header->count;
        }
        
        if (receiversCount == 0 && self.timer != nil) {
            lxd_wait(self.lock);
            dispatch_cancel(self.timer);
            self.timer = nil;
            lxd_signal(self.lock);
        }
    }
    
假如本次回调中正好所有的倒计时任务都处理完毕了，所有的注册者都被清除。也不会立刻停止定时器，而是等待到下次回调再停止。主要出于两个条件考虑：

1. 回调属于异步执行，如果要本次处理完成后检测注册队列状态，需要额外的同步机制开销

2. 假如在下次回调前又注册了新的倒计时任务，可以避免销毁重建定时器的开销

### 去重
按钮的倒计时是一种特殊的需求，一般在倒计时前后不会出现相同的二次任务。但是在商品抢购的需求中，同一个`cell`注册多次倒计时任务非常的常见，因此还要考虑如何设计去重。正好`@synchronized`有类似的去重设计可以借鉴，采用`hashmap + linked list`的设计。由于同一个对象在生命周期内地址是不变的，因此以地址进行`hash`运算：

    unsigned int LXDBaseHashmap::obj_hash_code(void *obj) {
        uint64_t *val1 = (uint64_t *)obj;
        uint64_t *val2 = val1 + 1;
        return (unsigned int)(*val1 + *val2) % hash_bucket_count;
    }

    bool LXDReceiverHashmap::insertReceiver(void *obj, LXDReceiverCallback callback, unsigned long lefttime) {
        unsigned int offset = obj_hash_code(obj);
        hash_entry_t *entry = hash_entries + offset;
        LXDReceiverNode *header = (LXDReceiverNode *)entry->entry;
        LXDReceiverNode *node = header->next;
        
        if (node == NULL) {
            LXDReceiver *receiver = create_receiver(obj, callback, lefttime);
            node = new LXDReceiverNode(receiver, header);
            header->next = node;
            header->count++;
            return true;
        }
        
        do {
            if (compare(node, obj) == true) {
                node->receiver->callback = callback;
                node->receiver->lefttime = lefttime;
                return false;
            }
        } while (node->next != NULL && (node = node->next));
        
        if (compare(node, obj) == true) {
            node->receiver->callback = callback;
            node->receiver->lefttime = lefttime;
            return false;
        }
        
        LXDReceiver *receiver = create_receiver(obj, callback, lefttime);
        node->next = new LXDReceiverNode(receiver, node);
        header->count++;
        return true;
    }

当匹配到同一个对象存在倒计时任务时，只需要更新任务的剩余时间和回调处理即可

### 前后台切换
应对前后台切换导致的时间错乱问题，上面我提出了三种方案。除了第`3`种方案毫无意义之外，需要在前两种做选择。由于我使用的数据结构中存储的是`lefttime`而不是`deadline`，使用第`2`中计算时间差值是最合适的做法：

    - (void)applicationDidBecameActive: (NSNotification *)notif {
        if (self.enterBackgroundTime && self.timer) {
            long delay = [[NSDate date] timeIntervalSinceDate: self.enterBackgroundTime];
            
            dispatch_suspend(self.timer);
            for (unsigned int offset = 0; offset < _receives->entries_count; offset++) {
                hash_entry_t *entry = _receives->hash_entries + offset;
                LXDReceiverNode *header = (LXDReceiverNode *)entry->entry;
                __block LXDReceiverNode *node = header->next;
                
                dispatch_async(dispatch_get_main_queue(), ^{
                    lxd_wait(self.lock);
                    while (node != NULL) {
                        LXDReceiver *receiver = node->receiver;
                        LXDReceiverNode *next = node->next;
                        receiver->lefttime -= delay;
                        
                        bool isStop = false;
                        receiver->callback(receiver->lefttime < 0 ? 0 : receiver->lefttime, &isStop);
                        if (receiver->lefttime <= 0 || isStop) {
                            _receives->destoryNode(node);
                            header->count--;
                        }
                        node = next;
                    }
                    lxd_signal(self.lock);
                });
            }
            dispatch_resume(self.timer);
        }
    }
    
    - (void)applicationDidEnterBackground: (NSNotification *)notif {
        self.enterBackgroundTime = [NSDate date];
    }

由于通知的回调线程和定时器的处理线程可能存在多线程的竞争，为了排除这一干扰，我采用了`sema`加锁，以及在遍历期间挂起定时器，减少不必要的麻烦

### 循环引用
首先，`block`的循环引用是很容易去避免的一个问题，但为了减少书写`__weak`的麻烦，可以在接口设计上去避免这个问题。由于这套倒计时方案并不局限于`UIButton`这个类，基于`NSObject`进行方法的扩展是最简单有效的方法：

    @interface NSObject (PerformTimer)

    /*!
     *  @method beginCountDown:forSeconds:
     *  启动倒计时任务
     *
     *  @params countDown   倒计时回调block
     *  @params seconds     倒计时长
     */
    - (void)beginCountDown: (LXDObjectCountDown)countDown forSeconds: (NSInteger)seconds;
    
    @end
    
    @implementation NSObject (PerformTimer)

    - (void)beginCountDown: (LXDObjectCountDown)countDown forSeconds: (NSInteger)seconds {
        if (countDown == nil || seconds <= 0) { return; }
        
        __weak typeof(self) weakself = self;
        [[LXDTimerManager timerManager] registerCountDown: ^(long leftTime, bool *isStop) {
            countDown(weakself, leftTime, (BOOL *)isStop);
        } forSeconds: seconds withReceiver: self];
    }
    
    @end

### 其他
还是要再次声明这个观点：

> 倒计时方案几乎没有门槛，但也不仅限于倒计时方案

设计一个功能需要经过仔细考虑多个因素，包括`逻辑`、`性能`、`质量`多个方面。本篇文章基于这段时间学习的收获总结而成，如果您觉得有不足之处，还万请指出。项目已同步至`cocoapods`，可通过`pod 'LXDTimerManager'`

[demo](https://github.com/sindrilin/LXDTimerManager)

