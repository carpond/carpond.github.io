---
title: 消费者-生产者
date: 2017-09-27 08:00:00
categories:
- 多线程
- 线程锁
- Note
---

`消费者-生产者`是一种并发环境下的解决方案，它通过增加缓存区域来平衡数据生产和数据处理的速度。打个比方，我们去银行柜台办事，都是取号后等待叫号。其中，我们是`生产者`、柜员是`消费者`、叫号是`缓存区`。如果没有叫号，我们必须等排在前面的人办完事情，期间一旦我们离开了队伍，就要重头排队。而有了叫号之后，我们在被叫到号码之前可以去做其他事情

> 那一天，人类终于回想起了曾一度被排队所支配的恐惧

由于`消费者-生产者`的特殊性质，在开发中我们往往享受了它带给我们的好处，却不知道哪些地方用到了这种设计，本文盘点下在我们开发过程中使用到的`消费者-生产者`设计

## 使用场景
严格来说，`消费者-生产者`是为了平衡两者因为执行速率不一导致的问题，因此在这种设计下存在两种情况：

- `生产 > 消费`

    常见的一种情况是多个网络请求完成，需要将请求数据存储到数据库中。为了避免多线程存储可能带来的数据破坏，回调操作一般会选择串行执行，此时的缓存区可以有两种形式：
        
    ![](http://upload-images.jianshu.io/upload_images/783864-d809ba515416c31f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    
    前者是网络请求结束后，将回调放到串行队列中执行。比如`AFNetworking`会统一回调到主线程，或者`RAC`的信号回调是串行执行的
 
        [session dataTaskWithRequest: request 
                    completionHandler: ^(NSData * _Nullable data, 
                                        NSURLResponse * _Nullable response, 
                                        NSError * _Nullable error) {
            if (error != nil) {
                dispatch_async(dispatch_get_main_queue(), ^ {
                    complete(data, error);
                });
            }
        }
 
    后者则是对数据库进行一层包装，将写入操作放到串行队列中
 
        - (void)insertData: (NSData *)data {
            dispatch_async(_dbQueue, ^{
                [_db executeUpdate: [self _insertSqlWithData: data];
            });
        }
    
- `消费 > 生产`
    相比起上一种情况，`消费者`速率高于`生产者`的场景比较隐晦，但也是平时开发中用的最多的情况：
     
    ![](http://upload-images.jianshu.io/upload_images/783864-a62271f729c63c24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
     
    实际上这种情况下也分为并行执行和串行执行两种形式。前者`GCD`拥有一个线程池，在任务执行之前会检测是否存在空闲的线程，如果不存在就创建一条新线程执行任务。这时候`消费者`大多数情况是多于`生产者`
 
        if (_threadsPool.count > 0) {
            Thread *thread = _threadsPool[0];
            thread.wakeup();
            thread.execute(task);
        } else {
            Thread *thread = Thread();
            thread.execute(task);
        }
 
    后一种要手动去维护一个线程池，可以参见[EvansMusic的回答](https://zhuanlan.zhihu.com/p/22834934)。当然，也可以维护一个`串行队列池`，以此控制`消费者`的数量：
 
        LXD_INLINE DispatchContext __LXDDispatchContextGetForQos(LXDQualityOfService qos) {
            static DispatchContext contexts[5];
            int count = (int)[NSProcessInfo processInfo].activeProcessorCount;
        count = MIN(1, MAX(count, LXD_QUEUE_MAX_COUNT));
            switch (qos) {
                case LXDQualityOfServiceUserInteractive: {
                    static dispatch_once_t once;
                    dispatch_once(&once, ^{
                        contexts[0] = __LXDDispatchContextCreate("com.sindrilin.user_interactive", count, qos);
                    });
                    return contexts[0];
                }
            
                case LXDQualityOfServiceUserInitiated: {
                    static dispatch_once_t once;
                    dispatch_once(&once, ^{
                        contexts[1] = __LXDDispatchContextCreate("com.sindrilin.user_initated", count, qos);
                    });
                    return contexts[1];
                }
            
                case LXDQualityOfServiceUtility: {
                    static dispatch_once_t once;
                    dispatch_once(&once, ^{
                        contexts[2] = __LXDDispatchContextCreate("com.sindrilin.utility", count, qos);
                    });
                    return contexts[2];
                }
            
                case LXDQualityOfServiceBackground: {
                    static dispatch_once_t once;
                    dispatch_once(&once, ^{
                        contexts[3] = __LXDDispatchContextCreate("com.sindrilin.background", count, qos);
                    });
                    return contexts[3];
                }
            
                case LXDQualityOfServiceDefault:
                default: {
                    static dispatch_once_t once;
                    dispatch_once(&once, ^{
                        contexts[4] = __LXDDispatchContextCreate("com.sindrilin.default", count, qos);
                });
                    return contexts[4];
                }
            }
        }

## 信号量
上文的场景全部以串行执行的方式来平衡`消费者`和`生产者`（即便是并发执行的队列，也能保证任务取出的顺序是有序的）。除了队列，`信号量`也是一种控制消费速率的手段，实际上这种手段可以看做是在`缓存区`和`消费者`之间加了一层限制：

![](http://upload-images.jianshu.io/upload_images/783864-42fb7e6a7871ef63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

对于信号量的实现可以参见[Semaphore原理与实现](http://www.jianshu.com/p/947153c6b409)

## 双缓冲区
`双缓冲区`的使用在笔者的印象中在硬件上的实现巨多，软件上见到的相对比较少，比如`GCD`就采用了双缓存区的方式。虽然`iOS`允许我们创建多个任务队列、并设置不同的优先级，但是任务最终会根据优先级和串行并行属性进入系统的全局队列中：

![](http://upload-images.jianshu.io/upload_images/783864-cf365326938674a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

每一种优先级的全局队列存在对应的`overcommit`队列，对应的是并行执行的任务，`overcommit`队列会尝试新建线程去执行并发处理。

## 其他
在多线程环境下，`生产者`只需要将产出`push`到队列中，等待`消费者`执行。作为这个设计的核心，`缓冲区`承担了很多的职责，也要考虑诸多因素：

- 同步和锁
 
    线程间处理避不可免要接触`死锁`、`同步`、`互斥`等疑难杂症，使用`锁`保护临界资源还是用`同步`控制执行顺序都有各自的优缺点
 
- 队列需求
 
    队列是`消费者-生产者`的常客，选择合适的队列缓冲区结构也是能更好的平衡两者速率的
 
## 尾话
`消费者-生产者`是一种经过漫长历史考验的代码设计之一，`缓冲区`的加入很好的避免了两者需要等待对方执行完成，很好的平衡了二者速率不一导致的资源浪费。也顺带也解除了两者的依赖，实现了解耦

